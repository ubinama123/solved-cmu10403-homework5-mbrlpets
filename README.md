Download Link: https://assignmentchef.com/product/solved-cmu10403-homework5-mbrl_pets
<br>
For this assignment, you will work with the Pushing2D-v1 environment, note that this environment is slightly <strong>different </strong>from the one you used in the previous homework. In particular, the state is now 10 dimensional and includes the velocity for the pusher and the box. To recap, in order to make the environment using gym, you can use the following code:

import gym import envs env = gym.make(“Pushing2D-v1”)

Then you can interact with the environment as you usually do. Similarly to Homework 4, the environment is considered “solved” once the percent of success (i.e., the box reaches the goal within the episode) reaches 90%. A render option is provided in the step function to provide a visualization.

<h1>1             Model-Based Reinforcement Learning with PETS</h1>

For this section, you will implement a model-based reinforcement learning (MBRL) method called <strong>PETS </strong>which stands for probabilistic ensemble and trajectory sampling [1]. There are 3 main components to MBRL with PETS:

<ol>

 <li>Probabilistic ensemble of networks: you will be using probabilistic networks that output a distribution over the resulting states given a state and action pair.</li>

 <li>Trajectory sampling: propagate hallucinated trajectories through time by passing hypothetical state-action pairs through different networks of the ensemble.</li>

 <li>Planning with model predictive control: Use the trajectory sampling method along with a cost function to perform planning and select good actions.</li>

</ol>

We will start with the third component. You will first implement CEM and MPC and test it on a ground truth dynamics. Then, you will replace the ground truth dynamics with a learned, probabilistic ensemble dynamics model. It is recommended to go through all the questions before you start the implementation.

<h2>1.1           Planning with Cross Entropy Method(CEM) [20 pts]</h2>

Before learning the model, let us first understand how do we obtain a policy from a dynamics model <em>p</em>(<em>s<sub>t</sub></em><sub>+1</sub>|<em>s<sub>t</sub>,a</em>). One approach is to train a model-free policy on the imagined trajectories generated by the model. Another simpler approach is to do random shooting, where an action

<strong>Algorithm 1 </strong>Cross Entropy Method (CEM)

1: <strong>procedure </strong>CEM(population size <em>M</em>, # elites <em>e</em>, # iters <em>I</em>, initial mean <em>µ</em>, initial std <em>σ</em>, plan horizon <em>T</em>, action dimensionality <em>A</em>)

2:               <strong>for </strong><em>i </em>in 1 : <em>I</em>:

3: Sample <em>M </em>action sequences <em>a</em><sub>1:<em>T,m </em></sub>according to <em>µ </em>and <em>σ </em>from normal distribution 4: where <em>a</em><sub>1:<em>T,m</em></sub><em>,µ </em>∈ R<em><sup>A</sup></em><sup>×<em>T </em></sup>and <em>σ </em>∈ R<em><sup>AT</sup></em><sup>×<em>AT </em></sup>is a diagonal covariance matrix.

5:                      <strong>for </strong><em>m </em>in 1 : <em>M</em>:

6:          Sample a trajectory <em>τ<sub>m </sub></em>= (<em>s</em><sub>1</sub><em>,a</em><sub>1</sub><em>,…,a<sub>T </sub>,s<sub>T</sub></em><sub>+1</sub>)<em><sub>m </sub></em>using the dynamics 7:  model <em>p</em>(<em>s<sub>t</sub></em><sub>+1</sub>|<em>s<sub>t</sub>,a<sub>t</sub></em>) and the action sequence <em>a</em><sub>1:<em>T,m </em></sub>where <em>s<sub>t </sub></em><sup>∈ </sup>R<em><sup>S</sup>,a<sub>t </sub></em><sup>∈ </sup>R<em><sup>A</sup></em>.

8:                            Calculate the cost of <em>a</em><sub>1:<em>T,m </em></sub>based on <em>τ<sub>m</sub></em>.

9:                      Update <em>µ </em>and <em>σ </em>using the top <em>e </em>action sequences.

<h3>10:          return: <em>µ </em>11: end procedure</h3>

sequence <em>a<sub>t</sub></em><sub>:<em>t</em>+<em>τ </em></sub>is optimized on the model to minimize a cost, which often works well. The Cross Entropy Method (CEM) is one of the popular random shooting algorithms. To make things precise, we show CEM in Algorithm 1. Note that when updating the variance of the actions, we assume that the actions across time are independent.

<strong>Cost Function </strong>In Line 8 of Algorithm 1, we need a cost function to evaluate the fitness of different states and action pairs. Defining the right cost function is often the hardest part of getting model-based reinforcement learning to work, since the action selection and resulting trajectories from CEM depend on the cost function. For this homework, you will be using the following cost function:

goal<em><sub>x </sub></em>

cost(<strong>pusher</strong><em>,</em><strong>box</strong><em>,</em><strong>goal</strong><em>,</em><strong>a</strong>) = <em>d</em>(pusher<em>,</em>box) + 2<em>d</em>(box<em>,</em>goal) + 5

goal<em><sub>y </sub></em>

where <em>d</em>(<em>p,q</em>) is the Euclidean distance between points <em>p </em>∈ R<sup>2 </sup>and <em>q </em>∈ R<sup>2</sup>. This function is already implemented in obs cost fn() of <em>mpc.py</em>. Given this state based cost, you can get the cost of a trajectory by summing up all the cost of all the states within one trajectory.

<strong>Policy from CEM </strong>When sampling trajectories using a policy with CEM, given a state, we can run Algorithm 1 and generate an action sequence of length <em>T</em>, which we can use in the future <em>T </em>time steps. On top of CEM, one thing can be done to give better planning results is Model Predictive Control (MPC), where we only use the first action in the planned action sequence and re-run CEM for each time step. The pseudocode is shown in Algorithm 2. MPC proceeds by starting with an initial <em>µ </em>and <em>σ </em>and use that as input to CEM. Then we take the updated <em>µ </em>from CEM and execute the action in the first time step in the environment to get a new state that we use for MPC in the next time step. We then update the <em>µ </em>that is used for the next timestep to be the <em>µ </em>from CEM for the remaining steps in the plan horizon and initialize the last time step to 0. Finally, we return all the state transitions gathered so that they can be appended to <em>D</em>.

<strong>Dynamics Model </strong>For Problem 1.1, use the ground truth dynamics, which can be accessed through the env.get nxt state function, which takes in the current state and action and generate the next state.

The hyper-parameters are summarized in Table 1.

<table width="398">

 <tbody>

  <tr>

   <td width="201">Parameter</td>

   <td width="197">Value</td>

  </tr>

  <tr>

   <td width="201">Population size <em>M</em></td>

   <td width="197">200</td>

  </tr>

  <tr>

   <td width="201">Action dimensionality <em>A</em></td>

   <td width="197">2</td>

  </tr>

  <tr>

   <td width="201">State dimensionality <em>S</em></td>

   <td width="197">8</td>

  </tr>

  <tr>

   <td width="201"># elites <em>e</em></td>

   <td width="197">20</td>

  </tr>

  <tr>

   <td width="201"># iters <em>I</em></td>

   <td width="197">5</td>

  </tr>

  <tr>

   <td width="201"># plan horizon <em>T</em></td>

   <td width="197">5</td>

  </tr>

  <tr>

   <td width="201">Initial mean <em>µ</em></td>

   <td width="197"><strong>0 </strong><sup>∈ </sup>R<em>A</em>×<em>T</em></td>

  </tr>

  <tr>

   <td width="201">Initial std <em>σ</em></td>

   <td width="197">0.5<strong>I </strong><sup>∈ </sup>R<em>AT</em>×<em>AT</em></td>

  </tr>

 </tbody>

</table>

Table 1: Summarized hyper-parameters.

<strong>Algorithm 2 </strong>Generating an episode using MPC

<table width="624">

 <tbody>

  <tr>

   <td colspan="2" width="624">1: <strong>procedure </strong>MPC(env, plan horizon <em>T</em>)2:                 transitions = []</td>

  </tr>

  <tr>

   <td width="50">3:</td>

   <td width="574"><em>s </em>= env.reset()</td>

  </tr>

  <tr>

   <td width="50">4:</td>

   <td width="574"><em>µ </em>= <strong>0</strong>, <em>σ </em>= 0.5<strong>I</strong></td>

  </tr>

  <tr>

   <td width="50">5:</td>

   <td width="574"><strong>while </strong>not done:</td>

  </tr>

  <tr>

   <td width="50">6:</td>

   <td width="574"><em>µ </em>=CEM(200, 20, 5, <em>µ</em>, <em>σ</em>)</td>

  </tr>

  <tr>

   <td width="50">7:</td>

   <td width="574"><em>a </em>= <em>µ</em>[0<em>,</em>:]</td>

  </tr>

  <tr>

   <td width="50">8:</td>

   <td width="574"><em>s</em><sup>0 </sup>= env.step(a)</td>

  </tr>

  <tr>

   <td width="50">9:</td>

   <td width="574">transitions.append(<em>s,a,s</em><sup>0</sup>)</td>

  </tr>

  <tr>

   <td width="50">10:</td>

   <td width="574"><em>s </em>= <em>s</em><sup>0</sup></td>

  </tr>

  <tr>

   <td width="50">11:</td>

   <td width="574"><em>µ </em>= <em>µ</em>[1 : <em>T</em>].append(<strong>0</strong>)</td>

  </tr>

  <tr>

   <td colspan="2" width="624">12:               <strong>return: </strong>transitions13: <strong>end procedure</strong></td>

  </tr>

 </tbody>

</table>

<ol>

 <li><strong> </strong>Before you begin to implement, we recommend going through how py works in a top-down manner. See how each component of the codes work toghether. For this question, implement CEM (solve function) in cem.py. You also need to implement act and predict next state gt functions in mpc.py. Then test it on the Pushing2D-v1 environment. The CEM policy you implement will also be used later for planning over a learned dynamics model. For all the questions in 1.1, we provide the starter code in the ExperimentGTDynamics class in run.py. All the hyper-parameters are provided in the code. Report the percentage of success over 50 episodes.</li>

 <li><strong> </strong>Instead of CEM, plan with random action sequences where each action is generated independently from a normal distribution N(<strong>0</strong><em>,</em>0<em>.</em>5<em>I</em>), where <em>I </em>is an identity matrix. Use the same number of trajectories for planning as CEM, i.e. for each state, sample M*I trajectories of length T and pick the best one. Implement this random planning method (solve function) in py. Report the percentage of success over 50 episodes. How does its performance compare to CEM?</li>

</ol>

<h3>3.</h3>

<ul>

 <li> Implement MPC for sampling trajectories in the function act in py.</li>

 <li> We provide another environment Pushing2DNoisyControl-v1, where a control noise is added to the algorithm. Test the two algorithm CEM and MPC+CEM on both environments and report the percentage of success over 50 episodes for each of them.</li>

 <li> Which algorithm performs better on which environments? Why? Discuss the pros and cons of MPC.</li>

</ul>

<h2>1.2           Probabilistic Ensemble and Trajectory Sampling (PETS) [70 pts]</h2>

<h3>Probabilistic Ensemble</h3>

Now, we will first try to learn a single probabilistic dynamics model but will show the algorithm in the form of learning the probabilistic ensemble.

You are provided starter code in model.py that specifies that model architecture that you will be using for each member of the ensemble. Specifically, each network is a fully connected network with 3-hidden layers, each with 400 hidden nodes. If you have trouble running this network, a smaller network may work as well, but may require additional hyperparameter tuning. The starter code also includes a method for calculating the output of each network, which will return the mean and log variance of the resulting states.

The training routine for the ensemble is shown in Algorithm 3. Consider defining a list of operations that you can run simultaneously with a single call to Session.run(). This will help speed up training significantly.

<strong>Algorithm 3 </strong>Training the Probabilistic Ensemble

1: <strong>procedure </strong>train(data <em>D</em>, # networks <em>N</em>, # epochs <em>E</em>)

2:              Sample |<em>D</em>| transitions from <em>D </em>for each network (sample with replacement).

3:               <strong>for </strong><em>e </em>in 1 : <em>E</em>:

4:                      <strong>for </strong><em>n </em>in 1 : <em>N</em>:

5:                         Shuffle the sampled transitions for network <em>n</em>.

6:                         Form batches of size <strong>128</strong>.

7:                           Loop through batches and take a gradient step of the loss for each batch.

<h3>8: end procedure</h3>

<strong>Single probabilistic network  </strong>Implement and train a single probabilistic network for 100 epochs on transitions from 1000 randomly sampled episodes and answer the following questions. You need to implement functions in model.py and predict next state model function in mpc.py.

Note: As the dynamics model is now probabilistic, when planning over the model using CEM (i.e. when generating trajectories from the dynamics model), you should sample <em>P </em>trajectories and use the average cost of the <em>P </em>trajectories. In this homework, we recommend using <em>P </em>= 6.

<ol>

 <li> The loss that you should use to train each network is the negative log likelihood of the actual resulting state under the predicted mean and variance from the network. Given state transition pairs <em>s<sub>t</sub>,a<sub>t</sub>,s<sub>t</sub></em><sub>+1</sub>, assuming the output distribution of the network is a Gaussian distribution N(<em>µ<sub>θ</sub></em>(<em>s<sub>n</sub>,a<sub>n</sub></em>)<em>,</em>Σ<em><sub>θ</sub></em>)<em>, </em>where <em>µ<sub>θ </sub></em>and Σ<em><sub>θ </sub></em>are outputs of the network. Derive the loss function L<sub>Gauss </sub>for training the network. You will note that both the <em>µ </em>and the Σ depend on the input state and action.</li>

 <li>Plot the loss and RMSE vs number of epochs trained for the single network.</li>

 <li> Combine your model with planning using randomly sampled actions + MPC. Evaluate the performance of your model when planning using a time horizon of 5 and 1000 possible action sequences. Do this by reporting the percent successes on 50 episodes.</li>

 <li>Combine your model with planning using CEM+MPC. Evaluate the performance of your model when planning using a time horizon of 5, a population of 200, 20 elites, and 5 epochs. Do this by reporting the percent successes on 50 episodes.</li>

 <li> Which planning method performs better, random or CEM? How did MPC using this model perform in general? When is the derived policy able to succeed and when does it fail?</li>

</ol>

<h3>Trajectory Sampling</h3>

With an ensemble of probabilistic dynamics model, how do we we sample trajectories from the ensemble model? One approach called TS1 sampling is to randomly pick one of the dynamics model at each time step of the trajectories. Algorithm 4 shows how TS1 determines which network to use for each time step. It is only one component of model predictive control and will be combined with the model and the planning method. Implement TS1 in predict next state model function in mpc.py.

Similar to single probabilistic case, we will sample <em>P </em>trajectories or particles, each of which represents a trajectory of length <em>T</em>.

<strong>Algorithm 4 </strong>Trajectory Sampling with TS1

1: <strong>procedure </strong>TS1(# networks <em>N</em>, # particles <em>P</em>, plan horizon <em>T</em>)

2:               Initialize array <em>S </em>of dimension <em>P </em>×<em>T </em>to store network assignments for each particle.

3:               <strong>for </strong><em>p </em>in 1 : <em>P</em>:

4:                          Randomly sample a sequence <em>s </em>of length <em>T </em>where <em>s </em>∈ {1<em>,…,N</em>}<em><sup>T </sup></em>.

5:                      Set <em>S</em>[<em>p,</em>:] = <em>s</em>.

<h3>6: end procedure</h3>

<strong>Algorithm 5 </strong>MBRL with PETS

1: <strong>procedure </strong>MBRL(# of epochs <em>I</em>)

2:               Initialize empty data array <em>D </em>and initialize probabilistic ensemble (PE) of models.

3:             Sample 100 episodes from the environment using random actions and store into <em>D</em>.

4:            Train ensemble of networks for 10 epochs.

5:              <strong>repeat </strong>for <em>I </em>epochs:

6:                        Sample 1 episode using MPC and latest PE and add to <em>D</em>.

7:                     Train PE for 5 epochs over <em>D</em>.

<h3>8: end procedure</h3>

<strong>MBRL with PETS </strong>.

<ol start="6">

 <li> Describe in detail your implementation of PETS. Include how you implement CEM, MPC, TS1. Include any additional hyper-parameters you need to tune other than the default hyper-parameters. Your response should walk the reader through your submitted code so that he/she will understand the key components of your implementation and be able to run your code with different arguments.</li>

 <li> Run Algorithm 5 for 500 epochs (i.e., collect 100 initial episodes and then 500 episodes using MPC). Plot the loss and RMSE vs number of epochs trained. This can take hours to run. Read though all the questions below before you start running this experiment.</li>

 <li> Every 50 epochs, test your model with both CEM+MPC and random actions+MPC on 20 episodes and report the percent of successes. Plot this as a function of the number of epochs of PETS. Which planning algorithm performs better? Combine this result with the observation in the single dynamics model and the ground truth dynamics cases, and discuss the comparison between CEM+MPC and random actions + MPC. Make sure to include both your observations and your explaination.</li>

 <li> What are some limitations of MBRL? Under which scenarios would you prefer MBRL to policy gradient methods like the ones you implemented in the previous homeworks?</li>

 <li>      Theoretical Questions</li>

</ol>

<ol>

 <li><strong>Aleatoric vs epistemic uncertainty. </strong>Aleatoric uncertainty is also known as statistical uncertainty and represents the random variability that is unpredictable, such as the outcome of a dice roll. Aleatoric uncertainty cannot be resolved by gathering more information. Epistemic uncertainty, also known as systematic uncertainty, which can be resolved by gathering more information. In the case of model-based RL, aleatoric uncertainty refers to the uncertainty due to the stochasticity in the environment and epistemic refers to the model error due to the capacity of the neural network or the difficulty in optimization. In the PETS framework, describe how we can measure the aleatoric and epistemic uncertainty. Make sure your description is specific such that a reader would be able to write practical algorithms to measure the two uncertainties based on your description.</li>

 <li> What is the failure mode if the aleatoric uncertainty is not considered? What is the failure mode if the epistemic uncertainty is not considered? In other word, describe in what ways a model-based agent will fail in these two cases.</li>

</ol>

<h1>Important Implementation Advice</h1>

It takes quite a while to run the experiments in this homework. Please plan accordingly and get started early! Please turn your homework in on time to facilitate grading! Again, to make debugging easier, you should implement your code piecewise and test each component as you build up your implementation, i.e., test the probabilistic ensemble, test the trajectory sampling, test the cross entropy method, test the cost calculation, test the MPC, etc.